---
title: "Take-home Exercise 01"
sidebar: false
pagetitle: "Take-home Ex 01"
---

```{r, include = FALSE}
pacman::p_load(tidyverse, dplyr, gganimate, ggiraph, ggplot2, crosstalk, ggrepel, ggthemes, lubridate, ggdist, ggridges, colorspace, ggstatsplot, ungeviz, plotly, DT, FunnelPlotR, knitr, scales, forecast, ggfortify)
```

## Background

The City of Engagement, with a total population of 50,000, is a small city located in the Country of Nowhere. The city serves as a service centre of an agriculture region surrounding the city. The main agriculture of the region is fruit farms and vineyards. The local council of the city is in the process of preparing the Local Plan 2023. A sample survey of 1000 representative residents had been conducted to collect data related to their household demographic and spending patterns, among other things. The city aims to use the data to assist with their major community revitalization efforts, including how to allocate a very large city renewal grant they have recently received.

## Data Preparation

There are two datasets for this exercise:

-   The first one contains various demographic information of survey participants (*Participants.csv*)

-   The second contains various financial transactions of survey participants (*FinancialJournal.csv*)

While importing the datasets, we will also ensure that the variables are of the correct type (e.g. character, numeric, integer):

### Load datasets

```{r}
#| results: hold
p <- read_csv("data/Participants.csv",
                     col_types = cols("i", "i", "l", "i", "c", "c", "d"))
if (any(is.na(p)) == FALSE) {
  cat("Output:", "There are no missing values in Participants.csv", "\n")
} else {
  cat("Output:", "There are missing values in Participants.csv", "\n")
}
p$educationLevel <-
  p$educationLevel %>% ordered(levels =
                                 c("Low",
                                   "HighSchoolOrCollege",
                                   "Bachelors",
                                   "Graduate")) # order of factors may be meaningful, so use ordered()
p_data <- distinct(p) # remove any possible duplicate rows

fin <- read_csv("data/FinancialJournal.csv",
                     col_types = cols("i", "T", "c", "d"))
if (any(is.na(fin)) == FALSE) {
  cat("Output:", "There are no missing values in FinancialJournal.csv", "\n")
} else {
  cat("Output:", "There are missing values in FinancialJournal.csv", "\n")
}
fin$category <-
  fin$category %>% factor(levels =
                            c("Education",
                              "Food",
                              "Recreation",
                              "RentAdjustment",
                              "Shelter",
                              "Wage"))
fin_data <- distinct(fin) # remove any possible duplicate rows
```

There were `r nrow(p) - nrow(p_data)` (out of `r nrow(p)`) duplicate rows for *Participants.csv* and `r nrow(fin) - nrow(fin_data)` (out of `r nrow(fin)`) duplicate rows for *FinancialJournal.csv*. They have been removed.

::: callout-note
## Information about col_types

"i" is for integer, "c" is for character, "l" is for logical, "d" is for double, "T" is for datetime.
:::

Before we move on, let's check if the financial journal is complete for all participants:

```{r}
counts <- fin_data %>% group_by(participantId) %>% summarise(n_obs = n())

ggplot(counts, aes(x = "", y = n_obs)) +
  geom_boxplot(fill = "#80b1d3", outlier.shape = NA, width = 0.5) +
  geom_jitter(width = 0.2, height = 0, alpha = 0.5, color = "#FFA07A") +
  scale_y_continuous(expand = c(0.05, 0)) +
  labs(title = "Distribution of Financial Transactions per participantId",
       subtitle = "Some participants have rather low numbers of financial transactions\n(located at the bottom)",
       y = "No. of financial transactions",
       x = "") +
  theme_classic() +
  theme(axis.line.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12))
```

For the group of participants that have rather low numbers of financial transactions, it could be due to exogenous reasons (e.g., data entry error, left the city, gave up on the study halfway). As such, they will be removed for the purposes of this analysis:

```{r}
new_fin_data <- counts %>%
  filter(n_obs >= 500) %>% # filter out participants with low no. of transactions
  inner_join(fin_data, by = "participantId") %>% # keep only relevant obs in fin_data
  select(!contains("n_obs")) # discard n_obs column
```

They will also be removed from the demographics dataset, since we are unsure if, for example, they have left the city for good.

```{r}
new_p_data <- counts %>%
  filter(n_obs >= 500) %>%
  inner_join(p_data, by = "participantId") %>%
  select(!contains("n_obs"))
```

::: callout-note
## Participants removed due to low number of check-ins in financial journal

A total of `r nrow(p_data) - nrow(new_p_data)` participants, out of the original `r nrow(p_data)`, were dropped from our datasets.
:::

## Getting to Know Our Demographics Dataset

The City of Engagement has a population of 50,000. We have participants' data with a sample size of `r nrow(new_p_data)`, which should give us a decent representation of how the population looks like.

Firstly, let's perform some basic visualisations so that we can get to know our data better. Basic insights are provided in the subtitle of each plot.

### Demographics of Participants

::: panel-tabset
## Household Size

```{r}
#| code-fold: true
#| code-summary: "Code"

# Creating a data.frame containing the frequencies of householdSize in our dataset of 1,000 participants
hs_counts <- data.frame(table(new_p_data$householdSize))
colnames(hs_counts) <- c("householdSize", "Freq")

# Adding a percentage variable based on the frequencies
hs_counts$pct <- percent(hs_counts$Freq / sum(hs_counts$Freq))

# Choosing some nice colors for the plot
nice_colors <- c("#80b1d3", "#8dd3c7", "#bebada")

# Plotting (using coord_polar creates a pie chart from a stacked bar chart)
ggplot(hs_counts, aes(x = "", y = Freq, fill = factor(householdSize))) + 
  geom_bar(stat = "identity", width = 1, color = "white") +
  geom_text(aes(label = pct), position = position_stack(vjust = 0.5)) +
  coord_polar("y", start = 0) +
  labs(title = "Household Size Distribution",
       subtitle = "The most common household size is 1 and least common household size is 3.",
       fill = "Household Size") +
  theme_void() +
  scale_fill_manual(values = nice_colors, guide = guide_legend(reverse = TRUE)) +
  theme(plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12))
```

## Kids?

```{r}
#| code-fold: true
#| code-summary: "Code"

# Creating a data.frame containing the frequencies of haveKids in our dataset of 1,000 participants
kids_counts <- data.frame(table(new_p_data$haveKids))
colnames(kids_counts) <- c("haveKids", "Freq")

# Adding a percentage variable based on the frequencies
kids_counts$pct <- percent(kids_counts$Freq / sum(kids_counts$Freq))

# Choosing some nice colors for the plot
nice_colors <- c("#80b1d3", "#8dd3c7")

# Plotting (using coord_polar creates a pie chart from a stacked bar chart)
ggplot(kids_counts, aes(x = "", y = Freq, fill = factor(haveKids))) + 
  geom_bar(stat = "identity", width = 1, color = "white") +
  geom_text(aes(label = pct), position = position_stack(vjust = 0.5)) +
  coord_polar("y", start = 0) +
  labs(title = "Distribution of Whether Participants Have Kids",
       subtitle = "Most participants do not have kids. Only slightly less than a third have kids.",
       fill = "Do participants have kids?") +
  theme_void() +
  scale_fill_manual(values = nice_colors, guide = guide_legend(reverse = TRUE)) +
  theme(plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12))
```

## Age

```{r}
#| code-fold: true
#| code-summary: "Code"

# Calculate the mean, min, and max age
mean_age <- mean(new_p_data$age)
min_age <- min(new_p_data$age)
max_age <- max(new_p_data$age)

# Choosing some nice colors for the plot
nice_colors <- c("#80b1d3", "#8dd3c7", "#bebada", "#fccde5")

# Plotting
ggplot(new_p_data, aes(x = age)) + 
  geom_histogram(breaks = c(18, 30, 40, 50, 60), fill = nice_colors, color = "white") +
  labs(title = "Age Distribution",
       subtitle = "Participants are relatively evenly distributed across age groups.",
       x = "Age",
       y = "Counts",
       caption = "Note:\nFor geom_histogram(), all bins are left-inclusive and right-exclusive by default, except the rightmost bin,\nwhich is both left and right-inclusive.\nThe leftmost and rightmost bins have a larger binwidth of 12 and 11 years respectively, compared to the\nmiddle two bins with binwidths of 10 years. Though not ideal for comparison, they are intuitive.") +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12),
        plot.caption = element_text(size = 9.5, hjust = 0)) +
  geom_vline(xintercept = mean_age, color = "darkred", linetype = "dashed") +
  geom_vline(xintercept = min_age, color = "darkred", linetype = "dashed") +
  geom_vline(xintercept = max_age, color = "darkred", linetype = "dashed") +
  annotate("text", x = mean_age + 4.2, y = 40, label = paste("Mean age:", round(mean_age, 1)), color = "darkred") +
  annotate("text", x = min_age + 3.5, y = 40, label = paste("Min. age:", round(min_age, 1)), color = "darkred") +
  annotate("text", x = max_age - 4, y = 40, label = paste("Max. age:", round(max_age, 1)), color = "darkred") +
  geom_text(aes(x = 23.5, y = 150, label = "18-29\nyears old"), size = 3.5) +
  geom_text(aes(x = 34, y = 150, label = "30-39\nyears old"), size = 3.5) +
  geom_text(aes(x = 44, y = 150, label = "40-49\nyears old"), size = 3.5) +
  geom_text(aes(x = 54.5, y = 150, label = "50-60\nyears old"), size = 3.5) +
  scale_y_continuous(breaks = breaks_width(50)) # this useful function is from the 'scales' package
```

## Education Level

```{r}
#| code-fold: true
#| code-summary: "Code"

# Creating a data.frame containing the frequencies of educationLevel in our dataset of 1,000 participants
edu_counts <- data.frame(table(new_p_data$educationLevel))
colnames(edu_counts) <- c("educationLevel", "Counts")

# Adding a percentage variable based on the frequencies
edu_counts$pct <- percent(edu_counts$Counts / sum(edu_counts$Counts))

# Choosing some nice colors for the plot
nice_colors <- c("#80b1d3", "#8dd3c7", "#bebada", "#fccde5")

# Plot
ggplot(edu_counts, aes(x = educationLevel, y = Counts)) +
  geom_bar(stat = "identity", fill = nice_colors, color = "white") +
  labs(title = "Education Level Distribution", x = "Education Level", y = "Counts",
       subtitle = "This city is rather well-educated.\n93.7% of participants have education higher than 'High School/College'.\n45.7% have education higher than Bachelor's degree.") +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12)) +
  geom_text(aes(label = pct), vjust = 1.5)
```

## Interest Group

```{r}
#| code-fold: true
#| code-summary: "Code"

# Creating a data.frame containing the frequencies of interestGroup in our dataset of 1,000 participants
interest_counts <- data.frame(table(new_p_data$interestGroup))
colnames(interest_counts) <- c("interestGroup", "Counts")

# Adding a percentage variable based on the frequencies
interest_counts$pct <- percent(interest_counts$Counts / sum(interest_counts$Counts), accuracy = 0.1)

# Plot
ggplot(interest_counts, aes(x = reorder(interestGroup, -Counts), y = Counts)) +
  geom_bar(stat = "identity", fill = "#80b1d3", color = "white") +
  labs(title = "Interest Group Distribution", x = "Interest Group", y = "Counts",
       subtitle = "Most common interest among participants is 'J', and least common interest is 'E'.") +
  theme_bw() +
  theme(plot.title = element_text(face = "bold", size = 16),
        plot.subtitle = element_text(size = 12)) +
  geom_text(aes(label = pct), vjust = 1.5)
```
:::

## More Data Preparation - Group Data

Let's take a look at the length (no. of rows) of our `new_fin_data`, which is the financial journal for our `r nrow(new_p_data)` participants:

```{r}
cat("Output:", "There are", nrow(new_fin_data), "rows", "in our dataset.", "\n")
```

This is rather large and it is due to the fact that each participant can have multiple transactions across different categories. To make the dataset more manageable without losing our ability to conduct meaningful analysis, we could extract the Month-Year from `timestamp` column that records the date and time of each record in POSIXct format. After extracting the Month-Year (as `month_year`), we will sum the total transaction amounts by `participantId`, `category`, and `month_year`:

```{r, message = FALSE}
grouped_data <-
  new_fin_data %>%
  mutate(month_year = floor_date(timestamp, "month")) %>%
  group_by(participantId, category, month_year) %>%
  summarise(total_amount = sum(amount)) %>%
  arrange(participantId, month_year) # sort by ascending
```

```{r}
head(grouped_data, 10)
```
With this grouped dataset, we can clearly see the expenditure/income for each participant, category, and month-year.

```{r}
cat("Output:", "There are", nrow(grouped_data), "rows", "in our new dataset.", "\n")
```

This is a much smaller dataset, which is more manageable, while still providing insights at the monthly interval.

```{r}
grouped_more_data <-
  group_by(grouped_data, category, month_year) %>%
  reframe(total_amount = sum(total_amount)) %>%
  arrange(month_year)

ggplot(data = grouped_more_data, aes(x = month_year, y = total_amount)) +
  geom_line(color = "steelblue") +
  facet_wrap(~category, scales = "free_y", nrow = 3, ncol = 2) +
  labs(x = "Month-Year", y = "Total Amount") +
  theme_bw()
```

